import org.jodconverter.Plugins

// External dependencies for the build script
buildscript {
    repositories {
        mavenCentral()
        maven { url "https://plugins.gradle.org/m2/" }

        //Needed only for SNAPSHOT versions
        //maven { url "http://oss.sonatype.org/content/repositories/snapshots/" }
    }

    dependencies {
        classpath Plugins.coveralls
        classpath Plugins.nebulaProject
        classpath Plugins.spotless
    }
}

description = '''
    JODConverter automates conversions between office document formats
    using LibreOffice or Apache OpenOffice. It automates all conversions
    supported by the running instance of OpenOffice/LibreOffice.
'''

group = 'org.jodconverter'
version = '4.3.0-SNAPSHOT'

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Properties

ext {
    baselineJavaVersion = JavaVersion.VERSION_1_8
    sourceEncoding = "UTF-8"

    // Set up different sub-project lists for individual configuration
    ext.javaProjects = subprojects.findAll {
        new File(it.projectDir, 'src/main/java').directory
    }
    ext.javaLibraryProjects = javaProjects.findAll {
        !it.name.contains('jodconverter-sample') &&
        !it.name.contains('jodconverter-cli')
    }
    ext.releasedProjects = javaProjects.findAll {
        !it.name.contains('jodconverter-sample')
    }
    ext.publishedProjects = javaLibraryProjects.findAll { true }
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Configuration

// Configuration to apply to all the projects
allprojects {

    group = rootProject.group
    version = rootProject.version

    repositories {
        mavenCentral()
    }
}

// Configure Java projects
configure(javaProjects) {
    //println("Configuring java for ${project.name}")
    apply from: "${rootProject.projectDir}/gradle/java-projects.gradle"
}

// Configure Java libraries projects
configure(javaLibraryProjects) {
    //println("Configuring java-library for ${project.name}")
    apply plugin: 'java-library'
}

configure(publishedProjects) {
    //println("Configuring publishing for ${project.name}")
    apply from: "${rootProject.projectDir}/gradle/published-projects.gradle"
}


// Distribution configuration
configure(releasedProjects) {

    apply plugin: 'distribution'

    // exclude jodconverter-cli since it has its own distribution configuration
    if (!project.name.contains('jodconverter-cli')) {
        distributions {
            main {
                distributionBaseName = project.name
                contents {
                    from jar, sourcesJar, javadocJar
                }
            }
        }
    }
}

// Copy all the distributions of the subprojects to the root project
task distZip(type: Zip) {
    description "Create full distribution zip"
    group "Distribution"
    archiveBaseName.set(project.name)

    //from releasedProjects.collect { it.tasks.matching { it.name == 'distZip' || it.name == 'distTar' } }
    from releasedProjects.collect { it.distZip }
}
project.tasks["distZip"].dependsOn releasedProjects*.distZip
//project.tasks["distZip"].dependsOn releasedProjects*.assembleDist

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Project

apply plugin: 'idea'
apply plugin: 'eclipse'
apply plugin: 'jacoco'
apply plugin: 'com.github.kt3k.coveralls'

// Exclude folders from IDEA project
idea {
    module {
        excludeDirs += file('.idea')
    }
}

// Creates an aggregated JaCoCo executionData for all
// the tests (unit tests and integration tests) found
// in sub Java projects 
task jacocoMerge(type: JacocoMerge) {
    description = 'Aggregates JaCoCo test and integration test coverage reports of all projects.'
    group = "Reporting"

    // Gather execution data from all subprojects
    releasedProjects.each { subproject ->
        executionData subproject.tasks.withType(Test)
    }
    doFirst {
        executionData = files(executionData.findAll { it.exists() })
    }
}

// Code coverage report for all the sub (java) projects
task jacocoRootReport(type: JacocoReport, group: 'Coverage reports') {
    description = 'Generates an aggregate report from all subprojects'
    dependsOn releasedProjects.test, releasedProjects.integTest, jacocoMerge

    additionalSourceDirs.setFrom(files(releasedProjects.sourceSets.main.allSource.srcDirs))
    sourceDirectories.setFrom(files(releasedProjects.sourceSets.main.allSource.srcDirs))
    classDirectories.setFrom(files(releasedProjects.sourceSets.main.output))
    executionData jacocoMerge.destinationFile

    reports {
        html.enabled = true // human readable
        xml.enabled = true // required by coveralls
    }
}

coveralls {
    sourceDirs = releasedProjects.sourceSets.main.allSource.srcDirs.flatten()
    jacocoReportPath = "${buildDir}/reports/jacoco/jacocoRootReport/jacocoRootReport.xml"
}

tasks.coveralls {
    group = 'Coverage reports'
    description = 'Uploads the aggregated coverage report to Coveralls'

    dependsOn jacocoRootReport
    onlyIf { System.env.'CI' }
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Utilities
task printConfigurations {
    group "Help"
    doLast {

        subprojects.findAll().each { p ->
            println "${p}"
            p.configurations.each { println "  | " + it.name }
            println ""
        }
    }
}